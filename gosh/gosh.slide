# gosh
Go at the command line
10 Feb 2023

Nick Wells
@nickgwells
https://github.com/nickwells

// ==========================================================================
## Why write Go at the command line?

An example from real life

: a large system
:
: tens of programs;
: 1000+ instances;
: 100's of hosts in multiple datacentres;
: several million lines of code.
:
: ... and gigabytes of logs
:
: Sometimes we would need to answer questions about the system

// ==========================================================================
## Finding and investigating problems

Look in the log files

Pull out the interesting bits

: You've got to filter the gold from the grit
:
: Catch the fish in the stream

// ==========================================================================
## Traditional Unix tools

- grep
- cut
- less
- wc
- uniq
- sed

: You can connect these in a pipeline to just show the relevant detail


// ==========================================================================
## Going further

If you need to do more than these tools allow.

You need a program.

: With a program you can
: - show just parts of lines under specific circumstances
: - do some arithmetic on the results
: - reformat things to make the results easier to understand

// ==========================================================================
## How big a program?

- small
- very short-lived

: Micro-programs, just a few lines long
: Run once and thrown away

// ==========================================================================
## Writing micro-programs is easy...

in the **shell**

<br>

```
echo $((6*7))
```
// ==========================================================================
## Writing micro-programs is easy...

<br>

```
echo $((6*7))
```

or **python**

<br>

```
python3 -c 'print(6*7)'
```

// ==========================================================================
## Writing micro-programs is easy...

<br>

```
echo $((6*7))
python3 -c 'print(6*7)'
```
or **perl**

<br>

```
perl -e 'print(6*7,"\n")'
```

// ==========================================================================
## Writing micro-programs is easy...

<br>

```
echo $((6*7))
python3 -c 'print(6*7)'
perl -e 'print(6*7,"\n")'
```

But not in **Go**

// ==========================================================================
## In Go it's a lot more work

<br>

You can't do it in a single line

// ==========================================================================
## In Go it's a lot more work

<br>

**Generate a temporary file**

<br>

```
t=$(tempfile -s .go)
```

: If you're using MacOS you'll need to install coreutils and use
:
: gmktemp --suffix .go

// ==========================================================================
## In Go it's a lot more work

<br>

```
t=$(tempfile -s .go)
```
<br>

**Write your program into the temporary file**

<br>

```
echo 'package main
import "fmt"
func main(){fmt.Println(6*7)}' > $t
```

: You need at least
: - a package statement,
: - an import statement
: - and a main function

// ==========================================================================
## In Go it's a lot more work

<br>

```
t=$(tempfile -s .go)
echo 'package main
import "fmt"
func main(){fmt.Println(6*7)}' > $t
```

<br>

**Run the program**

<br>

```
go run $t
```


// ==========================================================================
## In Go it's a lot more work

<br>

```
t=$(tempfile -s .go)
echo 'package main
import "fmt"
func main(){fmt.Println(6*7)}' > $t
go run $t
```

<br>

**tidy up afterwards**

<br>

```
rm $t
```

: you want to get rid of this program as soon as you've finished running it
: it's a single-use program

// ==========================================================================
## Problems with this solution

- it's a lot of typing
- there are several steps to remember
- for packages not in the standard library, you need a directory & a go.mod file as well

: How small a Go program would you write?
: Would you switch to Go if you'd started writing something in another language?


// ==========================================================================
## gosh to the rescue

.image _images/gosh.png


// ==========================================================================
## gosh to the rescue

- gosh lets you write a micro-program
- in Go
- at the command line:

<br>

```
gosh -e 'fmt.Println(6*7)'
```

: the -e parameter introduces the code to execute
: a lot of Unix tools use this parameter (it's sort of a standard)
:
: if you're more familiar with the python way -c does the same thing

// ==========================================================================
## gosh to the rescue

We print things a lot, so:

<br>

```
gosh -pln '6*7'
```

: the -pln parameter generates code that wraps its argument
: in a call to fmt.Println
:
: similarly, -p calls fmt.Print
: and -pf calls fmt.Printf


// ==========================================================================
## Installing gosh

<br>

```
go install github.com/nickwells/utilities/gosh@latest
```

// ==========================================================================
## Using gosh as a filter

Returning to the original problem, you can use gosh as a filter, reading from
its standard input.

Use the **run-in-readloop** (or **n**) parameter.

<br>

```
gosh -n \
    -e 'if len(_l.Text()) > 80 {' \
    -pln '_l.Text()' \
    -e '}'
```

: The -n parameter places the code in a loop.
: It reads each line into a bufio.Scanner
: either from STDIN or from listed files
:
: Note the use of the _l variable.
: Internal gosh variables all start with an underscore
:
: To see all the variables gosh might use:
: gosh -help-notes 'Gosh - var*'


// ==========================================================================
## Using gosh as a filter

Reading from a file line-by-line you often want to
split the line into parts.

Use the **split-line** (or **s**) parameter.

<br>

```
gosh -s \
    -e 'if _lp[3] == "Target" {' \
    -pln '_l.Text()' \
    -e '}'
```

: The -s parameter automatically splits the line into parts.
: It splits on whitespace by default.
: The parts are put into the _lp variable
:
: Note that you don't need to give the -n parameter, it is assumed
: if you are splitting lines

// ==========================================================================
## Examples

Examining values

```
gosh -e 'ctx := context.WithValue(context.Background(), "K", 42)' \
     -e 'pretty.Println(ctx)'
```

: Note that the 'pretty' package is not in the standard library
: It uses github.com/kr/pretty

// ==========================================================================
## Examples

Quickly exploring Go library behaviour

<br>

```
gosh -e 'fmt.Printf("%+4.9X\n", 42)'
gosh -pf '"%+4.9X\n", 42'
gosh -pf '"%+9.4X\n", 42'
gosh -pf '"%+9.3X\n", 42'
gosh -pf '"%+9X\n", 42'
gosh -pf '"%+9x\n", 42'
gosh -pf '"%+9o\n", 42'
```

// ==========================================================================
## Examples

Running a simple web-server.

Use the **http** parameter

<br>

```
gosh -http -web-pf '"Gosh Time: %s", time.Now()'
```

: Here gosh generates the body of an HTTP handler's ServeHTTP method
:
: The -web-pf printer writes to the ResponseWriter of the ServeHTTP method
:
: You can use the -http-handler parameter to specify a different HTTP handler
:
: By default, this will listen on port 8080 but you can change this with the
: -http-port parameter
:

// ==========================================================================
## Examples

Editing files in place.

Use the **in-place-edit** (or **i**) parameter

<br>

```
gosh -i \
  -e 'if strings.HasSuffix(_l.Text(), `/v3/param/paramset"`) { ' \
  -w-pln 'strings.Replace(_l.Text(), "/v3/", "/v5/", 1)' \
  -e '} else {' \
  -w-pln '_l.Text()' \
  -e '}' -- filename
```

You can use the **findCmpRm** command (from the same Repository
as gosh) to check the results.

: This will edit the file.
: The new text is written using the -w-p parameters.
:
: This can be used to change import statements to reflect a
: major version change
:
: The original file is preserved in a copy with the same name
: plus a '.orig' suffix
:
: If the given file does not exist it will fail, similarly if
: there is already a .orig backup for the file

// ==========================================================================
## Shebang

.code _code/hello

: Note that the script as shown (on MacOS) won't run.
: Highlight the issue with gosh being in different locations on different OSs
:
: filename: $PresentDir/gosh/_code/hello
:
: gosh -i \
:      -w-pln 'strings.Replace(_l.Text(), "#!/home", "#!/Users", 1)' \
:      -- ./gosh/_code/hello
// ==========================================================================
## Shebang

.code _code/hello2

: The `#gosh.param:` lines allow you to add some extra parameters to gosh.
:
: Note that Linux takes everything after the interpreter name as a single
: parameter so only the -shebang parameter can be given on the shebang line.
:
: The added parameters are to run the script with minimal extra commands
: and to allow it to be run by a user without the Go command in their path.
:
: filename: $PresentDir/gosh/_code/hello2

// ==========================================================================
## Snippets

Some fragments of code appear again and again.


// ==========================================================================
## Snippets

Some fragments of code appear again and again.

<br>

```
if err != nil {
   fmt.Println(err)
   os.Exit(1)
}
```

// ==========================================================================
## Snippets

Some fragments of code appear again and again.

<br>

```
if err != nil {
   fmt.Println(err)
   os.Exit(1)
}
```

gosh lets you replace this with

<br>

```
gosh -e '_, err := os.Open("nosuchfile")' \
     -e-s iferr
```

: see also web-server timeout with the abort snippet.
: This will automatically exit the program after GOSH_TTL seconds
:
: and the ruler snippet to see more easily the behaviour of the
: fmt.Printf formatting above

// ==========================================================================
## Snippets - listing what is available

You can see all the snippets available with the **snippet-list** parameter

<br>

```
gosh -snippet-list
```


// ==========================================================================
## Snippets - installing the standard snippets

**First install the gosh.snippet command**

<br>

```
go install github.com/nickwells/utilities/gosh.snippet@latest
```

: gosh provides some standard snippets which the gosh.snippet command can
: install for you

// ==========================================================================
## Snippets - installing the standard snippets

- Install the gosh.snippet command

**Then choose where to put them**

<br>

```
gosh -snippet-list-dir
```

: - gosh will search for snippets in a number of standard
:   directories and you can see what these are with
:   the snippet-list-dir parameter.
:
: - You can add to the list of directories to search with
:   the snippet-dir parameter

// ==========================================================================
## Snippets - installing the standard snippets

- Install the gosh.snippet command
- Choose where to put them

**Finally install them:**

<br>

```
gosh.snippet -to <dir> -action install
```


// ==========================================================================
## Snippets - writing your own

A snippet file is copied into the script so it should be correct Go code

The comments in a snippet can be meaningful. They can:

- describe what the snippet does and how to use it
- record which other snippets should be used with it and in what order
- populate the import statement

: gosh -help-note 'Gosh - snippet comments' will show you documentation for
: the various semantically meaningful snippet comments

// ==========================================================================
## What is gosh doing

You can see what gosh is doing using the **verbose** parameter

<br>

```
gosh -pln '"Hello, World!"' -verbose
```


// ==========================================================================
## Looking at the generated program

You can keep the generated program using the **keep** parameter

<br>

```
gosh -pln '"Hello, World!"' -keep
```

: You might also want to add the following parameters
:    -format to format the code
:    -add-comments to add line-by-line comments
:    -dont-run to stop the command being run; you just want to see the code

// ==========================================================================
## Getting help

<br>

```
gosh -help
gosh -help-all
gosh -help-full
gosh -help-short
gosh -help-show examples
gosh -help-show notes
```

: - gosh has a comprehensive user manual with notes and examples

// ==========================================================================
## Pros and cons of scripting

Pros:
- you have just the interesting code
- and none of the scaffolding
- the code is immediately visible as you run it
- you always use the latest versions of everything

: by "scaffolding" I mean
: - go.mod & go.sum,
: - main.go with the package name, the imports and the main func,
: - the directory and the executable
:
: - big programs benefit from this but the overhead for a µ-program is excessive
:
: - because the code is more concise it's easier to see what's happening
:
: by "everything" I mean
: - the latest version of packages you're using
: - and the latest version of Go
// ==========================================================================
## Pros and cons of scripting

Cons:
- you need `gosh` installed
- you need `Go` installed
- you need `gopls` or `goimports` installed (there are ways around this)
- a compiled binary doesn't change; a script changes as packages change
- it's slower
- it's less portable

: gosh suffers from the same problems as other scripting languages
:
: The differences in pathnames for gosh or Go between operating systems
: means you need to write different versions of scripts (particularly
: shebang scripts) for different OS's
// ==========================================================================
## For more details

These slides are available at <https://github.com/nickwells/presentations/gosh>

You can read the speaker's notes on the slide deck

To install gosh

```
go install github.com/nickwells/utilities/gosh@latest
```

For the standard snippets

```
go install github.com/nickwells/utilities/gosh.snippet@latest
gosh.snippet -to $HOME/.config/github.com/nickwells/utilities/gosh/snippets -install
```

Some tips for using gosh can be found at
<https://nickwells.github.io/GoRecipes/gosh.html>


